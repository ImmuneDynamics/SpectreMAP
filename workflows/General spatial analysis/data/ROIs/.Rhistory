"BUV661 B220",
"BUV737 CD11b",
"BUV805 CD8a",
"BV480 MHCII",
"BV570 CD4",
"BV650 CD62L")
#########################################################################################################
#### Create and save some tSNE/UMAP plots for the whole dataset
#########################################################################################################
### Plot some sample-oriented plots
setwd(OutputDirectory)
dir.create("Output-plots")
setwd("Output-plots")
Spectre::make.factor.plot(dat = cell.dat.sub,
x.axis = "UMAP_X",
y.axis = "UMAP_Y",
col.axis = sample.col,
align.xy.by = cell.dat.sub,
align.col.by = cell.dat.sub)
Spectre::make.factor.plot(dat = cell.dat.sub,
x.axis = "UMAP_X",
y.axis = "UMAP_Y",
col.axis = group.col,
align.xy.by = cell.dat.sub,
align.col.by = cell.dat.sub)
Spectre::make.multi.plot(dat = cell.dat.sub,
type = "factor",
x.axis = "UMAP_X",
y.axis = "UMAP_Y",
col.axis = group.col,
plot.by = sample.col,
align.xy.by = cell.dat.sub,
align.col.by = cell.dat.sub,
dot.size = 1)
Spectre::make.multi.plot(dat = cell.dat.sub,
type = "factor",
x.axis = "UMAP_X",
y.axis = "UMAP_Y",
col.axis = sample.col,
plot.by = group.col,
align.xy.by = cell.dat.sub,
align.col.by = cell.dat.sub,
plot.width = 20,
dot.size = 1)
### Plot some cluster-oriented plots
Spectre::make.factor.plot(dat = cell.dat.sub,
x.axis = "UMAP_X",
y.axis = "UMAP_Y",
col.axis = "FlowSOM_metacluster",
align.xy.by = cell.dat.sub,
align.col.by = cell.dat.sub,
add.label = TRUE)
### Plot some marker-oriented plots
setwd(OutputDirectory)
setwd("Output-plots")
dir.create("All samples")
setwd("All samples")
Spectre::make.multi.marker.plot(dat = cell.dat.sub,
x.axis = "UMAP_X",
y.axis = "UMAP_Y",
plot.by = c(CellularCols),
align.xy.by = cell.dat.sub,
align.col.by = cell.dat.sub,
figure.title = "Markers",
dot.size = 1,
save.each.plot = TRUE)
#########################################################################################################
#### Create tSNE/UMAP plots for each sample and group seperately
#########################################################################################################
### Plot some marker-oriented plots -- one set per sample
setwd(OutputDirectory)
setwd("Output-plots")
dir.create("By sample")
setwd("By sample")
for(i in as.matrix(unique(cell.dat.sub[[sample.col]]))){
for(a in ClusteringCols){
Spectre::make.colour.plot(dat = cell.dat.sub[cell.dat.sub[[sample.col]] == i,],
x.axis = "UMAP_X",
y.axis = "UMAP_Y",
col.axis = a,
title = paste0(i, "_", a),
align.xy.by = cell.dat.sub,
align.col.by = cell.dat.sub)
}
}
### Plot some marker-oriented plots -- one set per group
setwd(OutputDirectory)
setwd("Output-plots")
dir.create("By group")
setwd("By group")
for(i in as.matrix(unique(cell.dat.sub[[group.col]]))){
for(a in ClusteringCols){
Spectre::make.colour.plot(dat = cell.dat.sub[cell.dat.sub[[group.col]] == i,],
x.axis = "UMAP_X",
y.axis = "UMAP_Y",
col.axis = a,
title = paste0(i, "_", a),
align.xy.by = cell.dat.sub,
align.col.by = cell.dat.sub)
}
}
setwd(OutputDirectory)
setwd("Output-plots")
dir.create("By sample")
setwd("By sample")
for(i in as.matrix(unique(cell.dat.sub[[sample.col]]))){
for(a in CellularCols){
Spectre::make.colour.plot(dat = cell.dat.sub[cell.dat.sub[[sample.col]] == i,],
x.axis = "UMAP_X",
y.axis = "UMAP_Y",
col.axis = a,
title = paste0(i, "_", a),
align.xy.by = cell.dat.sub,
align.col.by = cell.dat.sub)
}
}
### Plot some marker-oriented plots -- one set per group
setwd(OutputDirectory)
setwd("Output-plots")
dir.create("By group")
setwd("By group")
for(i in as.matrix(unique(cell.dat.sub[[group.col]]))){
for(a in CellularCols){
Spectre::make.colour.plot(dat = cell.dat.sub[cell.dat.sub[[group.col]] == i,],
x.axis = "UMAP_X",
y.axis = "UMAP_Y",
col.axis = a,
title = paste0(i, "_", a),
align.xy.by = cell.dat.sub,
align.col.by = cell.dat.sub)
}
}
library(Spectre)
package.check()
package.load()
# package.check(group = "spatial")
# package.load(group = "spatial")
library(tiff)
library(rgeos)
library(raster)
library(Spectre)
package.check()
package.load()
# package.check(group = "spatial")
# package.load(group = "spatial")
library(tiff)
library(rgeos)
library(raster)
### Set directories
dirname(rstudioapi::getActiveDocumentContext()$path)            # Finds the directory where this script is located
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))     # Sets the working directory to where the script is located
getwd()
start.dr <- getwd()
start.dr
setwd("ROIs/")
roi.dir <- getwd()
setwd(start.dr)
setwd("measurement/")
measure.dir <- getwd()
setwd(start.dr)
### Read in spatial data
## Read in tiffs and mask
setwd(roi.dir)
list.dirs()
spatial.dat <- read.spatial.files(loc = roi.dir,
name = "spatial.dat",
ext = ".tiff",
mask.ext = "_mask.tiff",
convert.to.raster = TRUE)
as.matrix(names(spatial.dat))
spatial.dat[[1]]$tiffs
spatial.dat[[1]]$mask
#' read.spatial.files - read in TIFF files into a spatial data object (list of rasters)
#'
#' @export
read.spatial.files <- function(loc = getwd(), # Corresponding directory of ROI folders
name = "spatial.list",
ext = ".tiff",
mask.ext = "_mask.tiff",
convert.to.raster = TRUE)
{
## Testing data
# setwd("/Users/thomasa/Desktop/Desktop_items/Modified_Bodenmiller_pipeline/output/histocat/")
# loc <- getwd()
# name = "spatial.list"
# ext <- ".tiff"
# mask.ext <- "_mask.tiff"
# convert.to.raster = TRUE
setwd(loc)
ROIs <- list.dirs(loc, recursive = FALSE, full.names = FALSE)
ROI.list <- list()
for(i in ROIs){
#i <- ROIs[1]
setwd(loc)
setwd(i)
TIFFs <- list.files(getwd(), ext)
TIFF.list <- list()
for(a in TIFFs){
#a <- TIFFs[1]
TIFF.list[[a]] <- readTIFF(a)
if(convert.to.raster == TRUE){
tiff.map <- TIFF.list[[a]]
tiff.raster <- raster(tiff.map)
TIFF.list[[a]] <- tiff.raster
}
}
val <- grep(mask.ext, names(TIFF.list))
mask <- TIFF.list[val]
TIFF.list <- TIFF.list[-val]
ROI.list[[i]][["tiffs"]] <- TIFF.list
ROI.list[[i]][["mask"]] <- mask
}
setwd(loc)
## Review overall structure
# ROI.list$`20171228_spleen315_500x500_editedforFAS_s1_p9_r10_a10_ac`$tiffs
# ROI.list$`20171228_spleen315_500x500_editedforFAS_s1_p9_r10_a10_ac`$mask
return(ROI.list)
}
#' do.convert.mask.to.outline - convert mask rasters into polygons to create cell outlines
#'
#' @export
do.convert.mask.to.outline <- function(dat){
#dat < - spatial.list[["TAXXX 20190705 Liver 243788_s1_p1_r1_a1_ac"]][["TAXXX 20190705 Liver 243788_s1_p1_r1_a1_ac_ilastik_s2_Probabilities_mask.tiff"]]
message("Converting raster to polygons. Please be patient, this may take some time.")
pp <- rasterToPolygons(dat, dissolve=TRUE)
#outline <- fortify(pp)
outline <- pp
return(outline)
}
#' do.summarise.mask
#'
#' @export
do.summarise.mask <- function(dat, # list of rasters of one ROI
polygon, # polygon (mask) raster
fun = "mean"
){
## Create a list of 'raster' names for measurement
#dat <- spatial.list[["TAXXX 20190705 Liver 243788_s1_p1_r1_a1_ac"]]
raster.names <- names(dat)
#raster.names <- raster.names[c(1:3)]
## Setup initial mask summary data (X & Y centroids coordinates)
#polygon <- mask_01_outline
ply.df <- as.data.frame(polygon)
ply.df
ply.centroids <- gCentroid(polygon,byid=TRUE)
ply.centroids.df <- as.data.frame(ply.centroids)
ply.centroids.df # mask number, with X and Y coordinates
## Loop to measure information within centroid (can be sped up by parallelising? Or maybe better to just do these measurements in CellProfiler?)
message("Measuring expression information within cell masks. This might take some time, please be patient")
for(i in raster.names){
message(paste0("Calculating expression data within cell masks for ", i))
# i <- raster.names[[1]]
temp.dat <- dat[[i]]
extracted.dat = raster::extract(x = temp.dat, y = polygon, df = TRUE) # this is the time consuming step
extracted.dat.res <- aggregate(. ~ID, data = extracted.dat, FUN = fun)
colnames(extracted.dat.res)[2] <- i # should we be removing .tiff here? If we do should be the same in the other read.spatial function, to ensure matching consistency
ply.centroids.df <- cbind(ply.centroids.df, extracted.dat.res[2]) ## doing this would remove the necessity to calculate centroids within the 'make.spatial.plot' function
}
return(ply.centroids.df)
}
# https://geocompr.robinlovelace.net/geometric-operations.html
# rst <- spatial.list[["TAXXX 20190705 Liver 243788_s1_p1_r1_a1_ac"]][["168Er-CD8a-titration_Er168.tiff"]]
#
#
# test = raster::extract(x = rst, y = ply, df = TRUE)
# test
#
# test.res <- aggregate(. ~ID, data = test, FUN = "mean")
# colnames(test.res)[2] <- "DNA_01"
# test.res
#
# ###
#
# ttl <- cbind(ply.centroids.df, test.res[2]) ## doing this would remove the necessity to calculate centroids within the 'make.spatial.plot' function
# ttl
#' make.spatial.plot - Create a dot plot (X vs Y) coloured by a selected continuous column (e.g. marker expression)
#'
#' This function allows you to create a coloured XY plot where each cell is coloured by a selected column. Typically used to plot cells on tSNE1/2 or UMAP1/2 coloured by select cellular markers.
#'
#' @usage make.colour.plot()
#'
#' @return prints and saves a ggplot.
#'
#' @author Thomas M Ashhurst, \email{thomas.ashhurst@@sydney.edu.au}
#'
#' @references \url{https://sydneycytometry.org.au/spectre}
#'
#' @usage See \url{https://sydneycytometry.org.au/spectre} for usage instructions and vignettes.
#'
#' @examples
#' make.colour.plot()
#'
#' @export
make.spatial.plot <- function(dat,
x.axis,
y.axis,
col.axis,
raster.image,
raster.mask.polygons,
raster.label = "DNA1",
raster.mask.size = 0.1,
raster.mask.colour = "gold",
raster.min.threshold = 0.00,
raster.max.threshold = 0.99,
title = paste0("Spatial - ", col.axis),
col.min.threshold = 0.01,
col.max.threshold = 0.995,
colours = "spectral",
dot.size = 1.5,
dot.alpha = 0.6,
align.xy.by = dat, # choose a data frame to set absolute limits for X/Y/colour
align.col.by = dat,
save.to.disk = TRUE,
path = getwd(),
plot.width = 9,
plot.height = 7,
blank.axis = FALSE)
{
### TESTING
# library(raster)
# library(data.table)
# library(tiff)
# library(ggplot2)
#
# dat <- data.list[[1]]
# x.axis = "X_position"
# y.axis = "y-axis-invert"
# col.axis = "Cell_144NdFITCB220_Nd144"
# col.min.threshold = 0.01
# col.max.threshold = 0.995
# title = paste0("Spatial plot")
# colours = "spectral"
# dot.size = 2.5
# dot.alpha = 0.6
# align.xy.by = dat
# align.col.by = dat
# save.to.disk = FALSE
# path = getwd()
# plot.width = 9
# plot.height = 7
# blank.axis = FALSE
#
# names(spatial.list[[1]])[51]
#
# raster.image <- spatial.list[["TAXXX 20190705 Liver 243788_s1_p1_r1_a1_ac"]][["191Ir-DNA1_Ir191.tiff"]]
# raster.label <- "DNA1"
#
# raster.mask.outlines <- outline
# raster.mask.size <- 0.1
# raster.mask.colour <- "gold"
#
# raster.min.threshold <- 0.0
# raster.max.threshold <- 0.99
### Check that necessary packages are installed
if(!is.element('Spectre', installed.packages()[,1])) stop('Spectre is required but not installed')
if(!is.element('ggplot2', installed.packages()[,1])) stop('ggplot2 is required but not installed')
if(!is.element('scales', installed.packages()[,1])) stop('scales is required but not installed')
if(!is.element('colorRamps', installed.packages()[,1])) stop('colorRamps is required but not installed')
if(!is.element('ggthemes', installed.packages()[,1])) stop('ggthemes is required but not installed')
if(!is.element('RColorBrewer', installed.packages()[,1])) stop('RColorBrewer is required but not installed')
if(!is.element('raster', installed.packages()[,1])) stop('raster is required but not installed')
if(!is.element('rgeos', installed.packages()[,1])) stop('rgeos is required but not installed')
### Require packages
require(Spectre)
require(ggplot2)
require(scales)
require(colorRamps)
require(ggthemes)
require(RColorBrewer)
require(raster)
require(rgeos)
### Colour setup
# Jet
if(colours == "jet"){
colour.scheme <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))
}
# Spectral
if(colours == "spectral"){
spectral.list <- colorRampPalette(brewer.pal(11,"Spectral"))(50)
spectral.list <- rev(spectral.list)
colour.scheme <- colorRampPalette(c(spectral.list))
}
# Viridis
if(colours == "viridis"){
colour.scheme <- colorRampPalette(c(viridis_pal(option = "viridis")(50)))
}
# Inferno
if(colours == "inferno"){
colour.scheme <- colorRampPalette(c(viridis_pal(option = "inferno")(50)))
}
#Magma
if(colours == "magma"){
colour.scheme <- colorRampPalette(c(viridis_pal(option = "magma")(50)))
}
### Define limits
# Dot point colouration
if(is.null(align.col.by) == TRUE){
ColrMin <- quantile(dat[[col.axis]], probs = c(col.min.threshold))
ColrMax <- quantile(dat[[col.axis]], probs = c(col.max.threshold))
}
if(is.null(align.col.by) == FALSE){
ColrMin <- quantile(align.col.by[[col.axis]], probs = c(col.min.threshold))
ColrMax <- quantile(align.col.by[[col.axis]], probs = c(col.max.threshold))
}
### Preparat the raster data
## Image prep
tiff.p <- rasterToPoints(raster.image)
tiff.df <- data.frame(tiff.p)
colnames(tiff.df) <- c("x_axis", "y_axis", raster.label)
## Create cell outlines
outline <- fortify(raster.mask.polygons)
## Prep mask data - calculate centroids
centroids <- gCentroid(raster.mask.polygons,byid=TRUE)
centroid.xmin <- centroids@bbox[1]
centroid.xmax <- centroids@bbox[3]
centroid.ymin <- centroids@bbox[2]
centroid.ymax <- centroids@bbox[4]
## Normalise XY for cell centroids
plot.normalize <- function(dat, min, max){
return(((dat- min(dat)) / (max(dat)-min(dat))) * (max - min) + min)
}
# X AXIS
dat[[x.axis]] <- plot.normalize(dat = dat[[x.axis]], min = centroid.xmin, max = centroid.xmax)
# Y AXIS
dat[[y.axis]] <- plot.normalize(dat[[y.axis]], min = centroid.ymin, max = centroid.ymax)
## Raster colour limits
RastMin <- quantile(tiff.df[[3]], probs = c(raster.min.threshold))
RastMax <- quantile(tiff.df[[3]], probs = c(raster.max.threshold))
### Generate and show coloured plot
p <- ggplot(data=tiff.df, aes(x=tiff.df[[1]], y=tiff.df[[2]])) +
## Plot the raster (IMC image)
geom_raster(aes(fill=tiff.df[[3]])) +
scale_fill_gradient(raster.label,
low = "black",
high = "white",
limits=c(RastMin,RastMax),
oob=squish) +
## Plot the cell mask boundaries
geom_path(aes(x = long, y = lat, group = group),
data = outline,
size = raster.mask.size,
col = raster.mask.colour) +
## Plot the cell data points
geom_point(data=dat,
aes(x=dat[[x.axis]], y=dat[[y.axis]], color = dat[[col.axis]]),  #as.numeric(as.character(col))
size = dot.size, #dot.size
alpha = dot.alpha #,
# shape = 1
)+
scale_color_gradientn(colours = colour.scheme(50),
limits = (c(ColrMin,ColrMax)),
oob=squish,
name = col.axis) +
## Setup some themes
theme_bw() +
coord_equal() +
xlab(x.axis)+
ylab(y.axis)+
ggtitle(title)
## More themes
p <- p + theme(panel.background = element_rect(fill = "white", colour = "black", size = 0.5), # change 'colour' to black for informative axis
axis.title.x=element_text(color="Black", face="bold", size=18),
axis.title.y=element_text(color="Black", face="bold", size=18),
legend.text=element_text(size=12), # large = 30 # small = 8
legend.key.height=unit(1,"cm"), # large = 3 # small = 1.2
legend.key.width=unit(0.4,"cm"), # large = 1 # small = 0.4
#legend.title=element_blank(),
plot.title = element_text(color="Black", face="bold", size=16, hjust=0) # size 70 for large, # 18 for small
)
### Save ggplot to disk if desired
if(save.to.disk == TRUE){
ggsave(filename = paste0(title, ".png"),
plot = p,
path = path,
width = plot.width,
height = plot.height,
limitsize = FALSE)
}
print(p)
}
library(Spectre)
package.check()
package.load()
# package.check(group = "spatial")
# package.load(group = "spatial")
library(tiff)
library(rgeos)
library(raster)
### Set directories
dirname(rstudioapi::getActiveDocumentContext()$path)            # Finds the directory where this script is located
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))     # Sets the working directory to where the script is located
getwd()
start.dr <- getwd()
start.dr
setwd("ROIs/")
roi.dir <- getwd()
setwd(start.dr)
setwd("measurement/")
measure.dir <- getwd()
setwd(start.dr)
### Read in spatial data
## Read in tiffs and mask
setwd(roi.dir)
list.dirs()
spatial.dat <- read.spatial.files(loc = roi.dir,
name = "spatial.dat",
ext = ".tiff",
mask.ext = "_mask.tiff",
convert.to.raster = TRUE)
as.matrix(names(spatial.dat))
spatial.dat[[1]]$tiffs
spatial.dat[[1]]$mask
